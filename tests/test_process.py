import asyncio
import time
from unittest.mock import MagicMock

import pytest

from server.process import GladosProcess, GladosProcessManager


class TestGladosProcess:
    def test_initialization(self):
        """Ensure __init__ sets properties correctly."""
        mock_runner = MagicMock()
        p = GladosProcess("testvoice", mock_runner)

        assert p.voice_name == "testvoice"
        assert p.runner is mock_runner
        assert isinstance(p.last_used, int)

    def test_is_multispeaker(self):
        """is_multispeaker() should always return False."""
        p = GladosProcess("voice", MagicMock())
        assert p.is_multispeaker() is False

    @pytest.mark.asyncio
    async def test_run_tts_yields_audio_properties(self):
        """run_tts() should yield the audio tuple as generated by runner."""
        mock_runner = MagicMock()
        mock_audio = MagicMock()

        mock_audio.raw_data = b"abc123"
        mock_audio.frame_rate = 48000
        mock_audio.sample_width = 2
        mock_audio.channels = 1

        mock_runner.run_tts.return_value = mock_audio

        p = GladosProcess("voice", mock_runner)

        # Collect async generator output
        results = []
        async for item in p.run_tts("hello world", 1.0):
            results.append(item)

        assert len(results) == 1
        data, rate, width, channels = results[0]

        assert data == b"abc123"
        assert rate == 48000
        assert width == 2
        assert channels == 1

        mock_runner.run_tts.assert_called_once_with("hello world", 1.0)


class TestGladosProcessManager:
    @pytest.mark.asyncio
    async def test_initialization(self):
        mock_runner = MagicMock()
        mgr = GladosProcessManager(mock_runner)

        assert mgr.runner is mock_runner
        assert isinstance(mgr.processes, dict)
        assert hasattr(mgr, "processes_lock")

    @pytest.mark.asyncio
    async def test_get_process_creates_new(self):
        mock_runner = MagicMock()
        mgr = GladosProcessManager(mock_runner)

        proc = await mgr.get_process("voice1")

        assert "voice1" in mgr.processes
        assert proc.voice_name == "voice1"
        assert proc.runner is mock_runner

    @pytest.mark.asyncio
    async def test_get_process_reuses_existing(self):
        mock_runner = MagicMock()
        mgr = GladosProcessManager(mock_runner)

        p1 = await mgr.get_process("voice")
        old_timestamp = p1.last_used

        await asyncio.sleep(0.001)

        p2 = await mgr.get_process("voice")

        assert p1 is p2
        assert p2.last_used > old_timestamp  # timestamp updated

    @pytest.mark.asyncio
    async def test_get_process_thread_safety(self):
        """Ensure only one process is created even with concurrent calls."""
        mock_runner = MagicMock()
        mgr = GladosProcessManager(mock_runner)

        async def call():
            return await mgr.get_process("samevoice")

        results = await asyncio.gather(*[call() for _ in range(20)])

        # All should be the same instance
        assert len({id(r) for r in results}) == 1

        # Manager should have only one entry
        assert list(mgr.processes.keys()) == ["samevoice"]
